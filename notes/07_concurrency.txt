--------------------------------------------------------------------------------
Race conditions
--------------------------------------------------------------------------------
# Race conditions are a result of uncontrolled access to shared data (or)
# Race conditions come about as a result of shared access to resources.

Sources of concurrency:
----------------------
# Multiple user space are running, they can access your code in surprising
  combinations of ways.
# SMP systems can be executing code simultaneously on diffrent processors
# kernel code is preemptible: your drivers code can lose the processor at any
  time and the process that replaces it could also be running in your driver.
# Device interrupts are asynchronous events that can cause concurrent execution
  of your code
# The kernel also provides various mechanisms for delayed code execution, such
 as workqueues, tasklets, and timers, which can cause your code to run at any
 time
# Due to hot pluggable: your device couls simply disappear in middle of working
  with it.

Principles for avoiding race conditions
---------------------------------------
1) first rule of thumb to keep on mind as you design your driver is to avoid
shared resources whenever possible. If there is no concurrent access, there can
be no race conditions.
	So carefully written kernel code should have a minimum of sharing. The
most obvious application of this idea is to avoid the use of global variables.
							     ----------------
If you put a resource in a place where more than one thread of execution can
find it, there should be a strong reason for doing so.

2) Other important rule to consider i, when kernel code creates an object that
will be shared with any other part of the kernel, that object must continue to
exist (and function properly) until it is known that no outside references to it
exist.

Two requirements come out of this rule: no object can be made available to the
kernel until it is in a state where it can function properly, and references to
such objects must be tracked. In most cases, you’ll find that the kernel handles
reference counting for you, but there are always exceptions.

Mechansims to avoid race conditions:
-----------------------------------
# if there are any shared data, make operations on that data atomic, meaning
 that the entire operation happens at once. 

 To achieve this, we must setup critical sections: code that can be executed by
 only one thread at any given time.

# not all critical sections are the same.

# shared data between two process:
--------------------------------- 
> we can use a locking mechanism that might cause the other process to sleep
 while waiting for access to the critical section.

> while performing an operation, memory allocation with kmalloc, process could
  sleep. 

> we must use a locking primitive that works when a thread that owns the lock
  sleeps.

> Not all locking mechanisms can be used where sleeping is a possibility  

> For our present needs however, the mechanism that fits best is a semaphore.
 
Semaphores
----------
> semaphore is a single integer value combined with a pair of functions that are
 typically called P and V.
> A process wishing to enter a critical section will call P on the relevant
 semaphore; if the semaphore’s value is greater than zero, that value is
 decremented by one and the process continues.
> If, instead, the semaphore’s value is 0 (or less), the process must wait until
 somebody else releases the semaphore.
> Unlocking a semaphore is accomplished by calling V; this function increments
 the value of the semaphore and, if necessary, wakes up processes that are
 waiting.

Mutual exclusion/Mutex
----------------------
> When semaphore value is set to 1, such a semaphore can be held only by a
 single process or thread at any given time.
> semaphore used in this mode is sometimes called a mutex, an abbreviation of
 mutual exclusion.
> Almost all semaphores found in the Linux kernel are used for mutual exclusion

Linux implementation <asm/semaphore.h>
---------------------------------------
> The relevant type is struct semaphore; actual semaphores can be declared and
 initialized in a few ways. One is to create a semaphore directly, then set it
 up with sema_init:

 void sema_init(struct semaphore *sem, int val);
 # val is the initial value to assign to a semaphore.

 Kernel also provides a set of helper functions and macros, thus a mutex can be
 declared and initialized with one of the following:

 DECLARE_MUTEX(name); semaphore variable (called name ) that is initialized to 1

 DECLARE_MUTEX_LOCKED(name); variable initialized with 0.
 with this mutex starts out in a locked state.

> if mutex must be initialized at runtime, use one of the following:
  void init_MUTEX(struct semaphore *sem);
  void init_MUTEX_LOCKED(struct semaphore *sem);

> in linux P function is "down". Holding a semaphore
> V function is "up". Releasing a semaphore

 Variations of down:
--------------------
# void down(struct semaphore *sem);
down decrements the value of the semaphore and waits as long as need be.

# int down_interruptible(struct semaphore *sem);
down_interruptible does the same, but the operation is interruptible. The
interruptible version is almost always the one you will want; it allows a
user-space process that is waiting on a semaphore to be interrupted by the user.
however, if the operation is interrupted, the function returns a nonzero
value, and the caller does not hold the semaphore. 
Proper use of down_interruptible requires always checking the return value and
responding accordingly.

# int down_trylock(struct semaphore *sem);
The final version (down_trylock) never sleeps; if the semaphore is not available
at the time of the call, down_trylock returns immediately with a nonzero return
value.

up
----
# void up(struct semaphore *sem);
Once up has been called, the caller no longer holds the semaphore.

Any thread that takes out a semaphore is required to release it with one (and
only one) call to up. 

Special care is often required in error paths; if an error is encountered while
a semaphore is held, that semaphore must be released before returning the error
status to the caller.



