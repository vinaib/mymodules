Device numbers:
--------------------------------------------------------------------------------
<linux/types.h> : dev_t
--------------------------------------------------------------------------------
major: identifies the driver
minor: which device is being referred to. Driver can drive multiple devices.

data struct: dev_t (unsigned int): 32 bit:
				      12 bits for major number
				      20 bits for minor number

Even if 12 bits are allocated for major number, the maximum is 511.
What about 3 more bits?
--------------------------------------------------------------------------------
<linux/kdev_t.h>: Helper macros: 
--------------------------------------------------------------------------------
MAJOR(dev_t dev)
MINOR(dev_t dev)

MKDEV(int major, int minor)

--------------------------------------------------------------------------------
<linux/fs.h>: Allocating char Device numbers: static
--------------------------------------------------------------------------------
# int register_chrdev_region(dev_t first, unsigned int count, char *name);

register_chrdev_region works well if you know ahead of time exactly which device
numbers you want.

first: beginning device number of the range you would like to allocate
	minor: minor number portion of first is most often 0
	major: user has to choose cautiosly 
count: total number of contiguous device numbers you are requesting.
name: name is the name of the device. It will appear in /proc/devices and sysfs
      (/sys/dev/char/).

return: 0 on success
	< 0 on erro
--------------------------------------------------------------------------------
<linux/fs.h>: Allocating char Device numbers: Dynamic
--------------------------------------------------------------------------------
int alloc_chrdev_region(dev_t *dev, unsigned int firstminor, unsigned int count, 
		char *name);

kernel will allocate a major number for you on the fly

# dev is an output-only parameter that will, on successful completion, hold the 
  first number in your allocated range.

# firstminor should be the requested first minor number to use

# count and name parameters work like those given to request_chrdev_region

--------------------------------------------------------------------------------
<linux/fs.h>: Deallocating char Device numbers
--------------------------------------------------------------------------------
void unregister_chrdev_region(dev_t first, unsigned int count);

# Regardless of how you allocate your device number, free using
  unregister_chrdev_region.

# usual place to call would be in your module’s cleanup function

--------------------------------------------------------------------------------
Three important Data Structures: file_operations, file, inode <linux/fs.h>
--------------------------------------------------------------------------------
filp/file
# Each open file represented internally by a file structure. The file structure
# represents an open file. It is created by the kernel on open and is passed to
# any function that operates on the file, until the last close(all instances).

The most imp fields of struct file are:
---------------------------------------	
mode_t f_mode; FMODE_READ, FMODE_WRITE

loff_t f_pos;

struct file_operations *f_op;

struct dentry *f_dentry;
The directory entry (dentry) structure associated with the file. Device driver writ-
ers normally need not concern themselves with dentry structures, other than to
access the inode structure as filp->f_dentry->d_inode .

unsigned int f_flags: O_RDONLY , O_NONBLOCK, O_SYNC

filp->private_data: The open system call sets this pointer to NULL before
calling the open method for the driver. You are free to make its own use of the
field or to ignore it; private_data is a useful resource for preserving state
information across system calls.

drivers never create file structures; they only access structures created
elsewhere.

file_operations/f_ops
# and it is associated with its own set of functions (f_ops). The operations are
mostly in charge of implementing the system calls. The operations associated
with file. The kernel assigns the pointer as part of its implementation of
open. The value in filp->f_op is never saved by the kernel for later reference;
this means that you can change the file operations associated with your file, and
the new methods will be effective after you return to the caller. This practice
allows the implementation of several behaviors under the same major number
without introducing overhead at each system call.

# We can consider the file to be an “object” and the (f_ops) functions operating
  on it to be its “methods".

inode
The inode structure is used by the kernel internally to represent files. 
Therefore, it is different from the file structure that represents an open file
descriptor.There can be numerous file structures representing multiple open
descriptors on a single file, but they all point to a single inode structure.

As a general rule, only two fields of this structure are of interest for writing
driver code.

dev_t i_rdev;
For inodes that represent device files, this field contains the actual device number.

macros that can be used to obtain the major and minor number from an inode:
----------------------------------------------------------------------------
unsigned int iminor(struct inode *inode);
unsigned int imajor(struct inode *inode);

struct cdev *i_cdev;
struct cdev is the kernel’s internal structure that represents char devices; this
field contains a pointer to that structure when the inode refers to a char device
file.

--------------------------------------------------------------------------------
Char Device Registration : <linux/cdev.h>
--------------------------------------------------------------------------------
Before the kernel invokes your device’s operations, you must allocate and
register one or more of these structures.

There are two ways of allocating and initializing one of these structures. 

# If you wish to obtain a standalone cdev structure at runtime:

struct cdev *my_cdev = cdev_alloc();
my_cdev->ops = &my_fops;

# Chances are, however, that you will want to embed the cdev structure within a
device-specific structure of your own; that is what scull does. In that case,
you should initialize the structure that you have already allocated with:

void cdev_init(struct cdev *cdev, struct file_operations *fops);

# struct cdev has an owner field that should be set to THIS_MODULE.

Inform kernel about cdev:
-------------------------
int cdev_add(struct cdev *dev, dev_t num, unsigned int count);

as soon as cdev_add returns, your device is “live” and its operations can be
called by the kernel. You should not call cdev_add until your driver is
completely ready to handle operations on the device.

To remove a char device from the system, call:
----------------------------------------------
void cdev_del(struct cdev *dev);

Older way of char device registration:
---------------------------------------
int register_chrdev(unsigned int major, const char *name,
struct file_operations *fops);

int unregister_chrdev(unsigned int major, const char *name);

--------------------------------------------------------------------------------
The Open Method: int (*open)(struct inode *inode, struct file *filp);
--------------------------------------------------------------------------------
# used to do initialization

# Check for device-specific errors (such as device-not-ready or similar hardware
problems)

# Initialize the device if it is being opened for the first time

# Update the f_op pointer, if necessary

# Allocate and fill any data structure to be put in filp->private_data

# The first order of business, however, is usually to identify which device is being
opened. is it my device requested? Inode have the i_cdev which contains the cdev
struct we setup/added before through cdev_add(); The only problem is that we do
not normally want the cdev structure itself, we want the scull_dev structure
that contains the cdev structure.

struct scull_dev *sdevp;
	sdevp = container_of(inode->i_cdev, struct scull_dev, cdev);
filp->private_data = dev

--------------------------------------------------------------------------------
The Release Method: int (*release)(struct inode *inode, struct file *filp);
--------------------------------------------------------------------------------
The device method should perform the following tasks:

• Deallocate anything that open allocated in filp->private_data
• Shut down the device on last close

Relationship between close and relase:
--------------------------------------
the dup and fork system calls create copies of open files without
calling open. each of those copies is then closed at program termination, and 
not every close system call causes the release method to be invoked.

The kernel keeps a counter of how many times a file structure is being used.
Neither fork nor dup creates a new file structure (only open does that); they
just increment the counter in the existing structure. The close system call
executes the release method only when the counter for the file structure drops
to 0 , which happens when the structure is destroyed. This relationship between
the release method and the close system call guarantees that your driver sees
only one release call for each open.

the previous discussion applies even when the application terminates without
explicitly closing its open files: the kernel automatically closes any file at
process exit time by internally using the close system call.

relation between close and flush:
----------------------------------
Note that the flush method is called every time an application calls close.

--------------------------------------------------------------------------------
read/write Method:
ssize_t read(struct file *filp, char __user *buff, size_t count, loff_t *offp);

ssize_t write(struct file *filp, const char __user *buff, size_t count, 
		loff_t *offp);
--------------------------------------------------------------------------------
__user *buff argument to the read and write methods is a user space pointer.
Therefore it cannot be directly dereferenced by kernel code. 

Reasons why userspace pointer cannot be directly dereferenced by kernel code:
-> Depending on which architecture your driver is running on, and how the kernel
was configured, the user-space pointer may not be valid while running in kernel
mode at all. There may be no mapping for that address, or it could point to some
other, random data

-> Even if the pointer does mean the same thing in kernel space, user-space mem-
ory is paged, and the memory in question might not be resident in RAM when
the system call is made. Attempting to reference the user-space memory directly
could generate a page fault, which is something that kernel code is not allowed
to do. The result would be an “oops,” which would result in the death of the
process that made the system call.

-> The pointer in question has been supplied by a user program, which could be
buggy or malicious. If your driver ever blindly dereferences a user-supplied
pointer, it provides an open doorway allowing a user-space program to access or
overwrite memory anywhere in the system. If you do not wish to be responsible
for compromising the security of your users’ systems, you cannot ever derefer-
ence a user-space pointer directly.

<asm/uaccess.h>:
----------------------------
TO access the user-space buffer in order to get its job done. This access must
always be performed by special, kernel-supplied functions in order to be safe.

unsigned long copy_to_user(void __user *to,
	const void *from,
	unsigned long count);

unsigned long copy_from_user(void *to,
	const void __user *from,
	unsigned long count);

-> checks for whether the user space pointer is valid.
-> If the pointer is invalid, no copy is performed; 
-> if an invalid address is encountered during the copy, on the other hand, only
part of the data is copied.
-> In both cases, the return value is the amount of memory still to be copied.

Aside: (__copy_to_user,__copy_from_user vs copy_to_user, copy_from_user)
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
However, it’s worth noting that if you don’t need to check the user-space
pointer you can invoke __copy_to_user and __copy_from_user instead. This is
useful, for example, if you know you already checked the argument.

*Important*
+++++++++++
The net result for the driver writer is that any function that accesses user
space must be reentrant, must be able to execute concurrently with other driver
functions, and, in particular, must be in a position where it can legally
sleep.

read and write return value:
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
A return value greater than or equal to 0, instead, tells the calling program
how many bytes have been successfully transferred. If some data is transferred
correctly and then an error happens, the return value must be the count of bytes
successfully transferred, and the error does not get reported until the next
time the function is called. Implementing this convention requires, of course,
that your driver remember that the error has occurred so that it can return
the error status in the future.

The read method: RULES
--------------------------------------------------------------------------------
-> return value equal to count argument, the requested number of bytes
transferred. this is optimal case

-> return is positive and smaller than count. Only part of data has been
transferred. In these cases most applications retries the read.

-> return value is 0, end of file is reached.

-> return value is negative, which means error. typical values are EINTR/EFAULT.

-> read system could block if there is no data

-> if current read position is greater than the device size, the read method
returns 0 to signal that there is no data available. 
for example, this can happen if process A is reading the device while process B
opens it for writing, thus truncating the device to a length of 0. Process A
suddenly finds itself past end-of-file and the next read call returns 0.

The write method: RULES
--------------------------------------------------------------------------------
-> return value equal to count, the requested number of bytes has been
transferred

-> return is positive and smaller than count. only part of the data has been
transferred. The program will most likely retry writing the rest of the data.

-> return value is 0, nothing was written. This result is not an error, and
there is no reason to return an error code. Once again, the standard library
retries the call to write.

-> A negative value means an error occurred, as defined in <linux/errno.h>

-> blocking read, non blocking read

readv and writev
--------------------------------------------------------------------------------
These “vector” versions of read and write take an array of structures, each of
which contains a pointer to a buffer and a length value.

A readv call would then be expected to read the indicated amount into each
buffer in turn. writev, instead, would gather together the contents of each
buffer and put them out as a single write operation.

If your driver does not supply methods to handle the vector operations, readv
and writev are implemented with multiple calls to your read and write methods.
In many situations, however, greater efficiency is acheived by implementing
readv and writev directly.

The prototypes for the vector operations are:

ssize_t (*readv) (struct file *filp, const struct iovec *iov,
	unsigned long count, loff_t *ppos);

ssize_t (*writev) (struct file *filp, const struct iovec *iov,
	unsigned long count, loff_t *ppos);

-> The iovec structure, defined in <linux/uio.h>
struct iovec {
	void _ _user *iov_base;
	__kernel_size_t iov_len;
};
-> Each iovec describes one chunk of data to be transferred; it starts at
iov_base (in user space) and is iov_len bytes long.

-> The count parameter tells the method how many iovec structures there are.
These structures are created by the application, but the kernel copies them into
kernel space before calling the driver.

-> The simplest implementation of the vectored operations would be a
straightforward loop that just passes the address and length out of each iovec
to the driver’s read or write function. Often, however, efficient and correct
behavior requires that the driver do something smarter.

--------------------------------------------------------------------------------
ioctl: 
--------------------------------------------------------------------------------
-> IOCTL is a common interface for device control

-> In user space, the ioctl system call has the following prototype:
	int ioctl(int fd, unsigned long cmd, ...);
	
	The third argument does not represents variable arguments, but a single
	optional argument, traditionally identified as char *argp.

	The actual nature of the third argument depends on the specific control
	command being issued (the second argument). Some commands take no arguments,
	some take an integer value, and some take a pointer to other data.

-> The ioctl driver method prototype 
	int (*ioctl) (struct inode *inode, struct file *filp, unsigned int cmd,
			unsigned long arg);

-> The inode and filp pointers are the values corresponding to the file
descriptor fd passed on by the application and are the same parameters passed to
the open method.

-> The cmd argument is passed from the user unchanged, 

-> and the optional arg argument is passed in the form of an unsigned long ,
regardless of whether it was given by the user as an integer or a pointer.
If the invoking program doesn’t pass a third argument, the arg value
received by the driver operation is undefined. Because type checking is
disabled on the extra argument.




--------------------------------------------------------------------------------
ioctl: unlocked_ioctl/compat_ioctl
--------------------------------------------------------------------------------
source: https://lwn.net/Articles/119652/

The ioctl() system call has long been out of favor among the kernel developers,
who see it as a completely uncontrolled entry point into the kernel. Given
the vast number of applications which expect ioctl() to be present, however,
it will not go away anytime soon. So it is worth the trouble to ensure that
ioctl() calls are performed quickly and correctly - and that they do not
unnecessarily impact the rest of the system.

ioctl() is one of the remaining parts of the kernel which runs under the Big
Kernel Lock (BKL). In the past, the usage of the BKL has made it possible for
long-running ioctl() methods to create long latencies for unrelated processes.
Recent changes, which have made BKL-covered code preemptible, have mitigated
that problem somewhat. Even so, the desire to eventually get rid of the BKL
altogether suggests that ioctl() should move out from under its protection.

Simply removing the lock_kernel() call before calling ioctl() methods is not an
option, however. Each one of those methods must first be audited to see what
other locking may be necessary for it to run safely outside of the BKL. That is
a huge job, one which would be hard to do in a single "flag day" operation. So a
migration path must be provided. As of 2.6.11, that path will exist.

The patch (by Michael s. Tsirkin) adds a new member to the file_operations
structure:

    long (*unlocked_ioctl) (struct file *filp, unsigned int cmd,
                            unsigned long arg);

If a driver or filesystem provides an unlocked_ioctl() method, it will be called
in preference to the older ioctl(). The differences are that the inode argument
is not provided (it's available as filp->f_dentry->d_inode) and the BKL is not
taken prior to the call. All new code should be written with its own locking,
and should use unlocked_ioctl(). Old code should be converted as time
allows. For code which must run on multiple kernels, there is a new
HAVE_UNLOCKED_IOCTL macro which can be tested to see if the newer method
is available or not.

Michael's patch adds one other operation:

    long (*compat_ioctl) (struct file *filp, unsigned int cmd,
                          unsigned long arg);

If this method exists, it will be called (without the BKL) whenever a 32-bit
process calls ioctl() on a 64-bit system. It should then do whatever is required
to convert the argument to native data types and carry out the request. If
compat_ioctl() is not provided, the older conversion mechanism will be used, as
before. The HAVE_COMPAT_IOCTL macro can be tested to see if this mechanism is
available on any given kernel.

The compat_ioctl() method will probably filter down into a few subsystems. Andi
Kleen has posted patches adding new compat_ioctl() methods to the
block_device_operations and scsi_host_template structures, for example, though
those patches have not been merged as of this writing.

There are a few noteworthy points about compat_ioctl:

-> If you are writing a new device driver that needs ioctl methods (which some
might argue you should not do in the first place), make sure the
data structure are compatible between 32 and 64 bit, so unlocked_ioctl and
compat_ioctl can point to the same function. In particular, data structures
containing must not contain fields that have different sizes (e.g. 'void *' or
'long') or need padding (e.g. 'long long' after 'int') on 64 bit systems.

-> As of 2.6.14, nobody has started converting the network layer to
compat_ioctl, so the next person that needs new compatibility code for socket
ioctls should add the infrastructure for that instead of adding on to
fs/compat_ioctl.c.

-> While the fs/compat_ioctl.c infrastructure still exists, it is valid for
compat_ioctl methods to return -ENOIOCTLCMD for anything they don't know. This
is particularly useful for block or tty devices that have a lot of ioctl numbers
common to all drivers. The vfs layer first calls ->compat_ioctl and if that does
not exist or returns -ENOIOCTLCMD, it scans the list of known conversions
between 32 and 64 bit ioctls and if it finds a valid conversion, it enters the
native 64 bit ->unlocked_ioctl/->ioctl path.


